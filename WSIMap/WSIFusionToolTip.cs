using System;
using System.ComponentModel;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace WSIMap
{
	public partial class WSIFusionToolTip : ToolTip
	{
		private FeatureCollection features;

		private System.Drawing.Font font = new System.Drawing.Font("Courier New", 9.0F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
		//private System.Drawing.Font defaultFont = new System.Drawing.Font("Tahoma", 11.0F, System.Drawing.FontStyle.Regular, (System.Drawing.GraphicsUnit)0, ((byte)(1)));
		/// <summary>
		/// Gets or sets the font to use for the tooltip.
		/// </summary>
		[Description("Set tooltip font")]
		[DefaultValue(typeof(Font), "Courier New, 9pt")]
		public System.Drawing.Font Font
		{
			get { return font; }
			set { font = value; }
		}

		private string toolTipText = string.Empty;
		/// <summary>
		/// Gets the tooltip text.
		/// </summary>
		public string ToolTipText
		{
			get
			{
				return toolTipText;
			}
		}

		/// <summary>
		/// Initialize the tooltip.
		/// </summary>
		public WSIFusionToolTip()
		{
			InitializeComponent();

			this.OwnerDraw = true;
			this.Popup += new PopupEventHandler(WSIFusionToolTip_Popup);
			this.Draw += new DrawToolTipEventHandler(WSIFusionToolTip_Draw);
		}

		/// <summary>
		/// Assigns the tooltip to the control using the FeatureCollection to set the text.
		/// </summary>
		/// <param name="control"></param>
		/// <param name="fc"></param>
		public void SetToolTip(Control control, FeatureCollection fc, string info)
		{
			features = fc;
			toolTipText = info;
			//Active = true;

			// Try to fix tooltip display cut-off 
			int newWidth = 0;
			for (int i = 0; i < features.Count; i++)
			{
				Feature f = features[i];
				Size currSize = TextRenderer.MeasureText(f.FeatureInfo, font);

				if (currSize.Width > newWidth)
					newWidth = currSize.Width;

			}

			StringBuilder s = new StringBuilder();
			//s.Append(' ', newWidth / 3);                  // In some case, still see the cut-off display
			s.Append('A', newWidth / 6);
			//Console.WriteLine("Append new size: " + newWidth);
			base.SetToolTip(control, string.Concat(s, '\n', info));
		}

		/// <summary>
		/// Clears the tooltip from the display.
		/// </summary>
		/// <param name="control"></param>
		/// <param name="caption"></param>
		public new void SetToolTip(Control control, string caption)
		{
			features = null;
			toolTipText = string.Empty;
			//Active = false;
			base.SetToolTip(control, string.Empty);
		}

		/// <summary>
		/// This method must figure out how big the tooltip is and set e.ToolTipSize.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		void WSIFusionToolTip_Popup(object sender, PopupEventArgs e)
		{
			//Console.WriteLine("old size {0}, {1}", e.ToolTipSize.Width, e.ToolTipSize.Height);
			if (features == null || features.Count == 0)
			{
				e.ToolTipSize = new Size(0, 0);
				return;
			}

			SizeF size = new SizeF(0, 0);

			Graphics g = e.AssociatedControl.CreateGraphics();

			for (int i = 0; i < features.Count; i++)
			{
				Feature f = features[i];
				SizeF currSize = g.MeasureString(f.FeatureInfo, font);

				if (currSize.Width > size.Width)
					size.Width = currSize.Width;
				size.Height += currSize.Height;
			}

			g.Dispose();
			e.ToolTipSize = new Size((int)size.Width, (int)size.Height);
			//Console.WriteLine("new size {0}, {1}", e.ToolTipSize.Width, e.ToolTipSize.Height);
		}

		/// <summary>
		/// Draw the tooltip based on the stored FeatureCollection and the size generated by the popup method.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		void WSIFusionToolTip_Draw(object sender, DrawToolTipEventArgs e)
		{
			if (features == null || features.Count == 0)
				return;

			Color backColor;
			int currVertPosition = 0;

			using (SolidBrush textBrush = new SolidBrush(Color.Black))
			{
				using (Pen linePen = new Pen(Color.Black, 1))
				{
					// Draw each feature's tooltip.
					for (int i = 0; i < features.Count; i++)
					{
						Feature f = features[i];

                        if (f is Polygon)
                        {
                            backColor = (f as Polygon).FillColor;
                            if (backColor == Color.Transparent)
                                backColor = (f as Polygon).BorderColor;
                        }
                        else if (f is Curve)
                        {
                            Curve c = f as Curve;
                            if (c.Color2 != Color.Empty)
                                backColor = c.Color2;
                            else
                                backColor = c.Color;
                        }
                        else if (f is Line)
                            backColor = (f as Line).Color;
                        else if (f is Circle)
                        {
                            backColor = (f as Circle).FillColor;
                            if (backColor == Color.Transparent)
                                backColor = (f as Circle).BorderColor;
                        }
                        else if (f is Ellipse)
                            backColor = (f as Ellipse).FillColor;
                        else if (f is PIREPSymbol)
                            backColor = (f as PIREPSymbol).Color;
                        else if (f is RadarSummarySymbol)
                            backColor = (f as RadarSummarySymbol).Color;
                        else if (f is Symbol)
                            backColor = (f as Symbol).Color;
                        else if (f is NavaidSymbol)
                            backColor = (f as NavaidSymbol).Color;
                        else if (f is PointD)
                            backColor = (f as PointD).Color;
                        else if (f is EWSDSymbol)
                            backColor = (f as EWSDSymbol).TriangleFillColor;
                        else if (f is VolcanoSymbol)
                            backColor = (f as VolcanoSymbol).Color;
                        else
                            backColor = Color.White;

						if (backColor == Color.Transparent)
							backColor = Color.White;
                        if (backColor.A < 255)
                            backColor = Color.FromArgb(backColor.R, backColor.G, backColor.B);
						SizeF size = e.Graphics.MeasureString(f.FeatureInfo, font);

						// Draw the custom background.
						using (SolidBrush backgroundBrush = new SolidBrush(backColor))
						{
							Rectangle backgroundRect = new Rectangle(new Point(0, currVertPosition), new Size(e.Bounds.Width, (int)size.Height));

							e.Graphics.FillRectangle(backgroundBrush, backgroundRect);
						}

						// Find a text color with sufficient contrast to the background color
						textBrush.Color = FUL.Utils.GetContrastingTextColor(backColor);

						// Write the text.
						e.Graphics.DrawString(f.FeatureInfo, font, textBrush, new Point(0, currVertPosition));

						// Draw a seperator line between this one and the previous one.
						if (i > 0)
							e.Graphics.DrawLine(linePen, new Point(0, currVertPosition), new Point(e.Bounds.Width, currVertPosition));

						currVertPosition += (int)size.Height;
					}

					// Draw the border.
					Rectangle bounds = e.Bounds;
					bounds.Width -= 1;
					//bounds.Height -= 1;
					bounds.Height = currVertPosition - 1;
					e.Graphics.DrawRectangle(linePen, bounds);
				}
			}
		}
	}
}
